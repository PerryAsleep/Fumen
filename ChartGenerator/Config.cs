using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Fumen;
using System.Text.RegularExpressions;
using Fumen.Converters;

namespace ChartGenerator
{
	/// <summary>
	/// Enumeration of methods for overwriting charts.
	/// </summary>
	public enum OverwriteBehavior
	{
		/// <summary>
		/// Do no overwrite charts that match the output type.
		/// </summary>
		DoNotOverwrite,
		/// <summary>
		/// Overwrite existing charts if they were generated by this program.
		/// </summary>
		IfFumenGenerated,
		/// <summary>
		/// Overwrite existing charts if they were generated by this program and they
		/// were generated at an older version.
		/// </summary>
		IfFumenGeneratedAndNewerVersion,
		/// <summary>
		/// Always overwrite any existing charts.
		/// </summary>
		Always
	}

	/// <summary>
	/// Enumeration of methods for copying files.
	/// </summary>
	public enum CopyBehavior
	{
		/// <summary>
		/// Do not copy the file.
		/// </summary>
		DoNotCopy,
		/// <summary>
		/// Copy the file if it is newer than the destination file.
		/// </summary>
		IfNewer,
		/// <summary>
		/// Always copy the file.
		/// </summary>
		Always
	}

	/// <summary>
	/// Configuration for ChartGenerator.
	/// Deserialized from json config file.
	/// Use Load to load Config.
	/// </summary>
	public class Config
	{
		/// <summary>
		/// File to use for deserializing Config.
		/// </summary>
		private const string FileName = "config.json";
		/// <summary>
		/// Tag for logging messages.
		/// </summary>
		private const string LogTag = "Config";

		/// <summary>
		/// Static Config instance.
		/// </summary>
		public static Config Instance { get; private set; }

		[JsonInclude] public string InputDirectory;
		[JsonInclude] public string InputNameRegex;
		[JsonInclude] public string InputChartType;
		[JsonInclude] public string OutputDirectory;
		[JsonInclude] public string DifficultyRegex;
		[JsonInclude] public string OutputChartType;
		[JsonInclude] public OverwriteBehavior OverwriteBehavior = OverwriteBehavior.DoNotOverwrite;
		[JsonInclude] public bool OutputVisualizations = true;
		[JsonInclude] public string VisualizationsDirectory;
		[JsonInclude] public Dictionary<string, List<int>> DesiredArrowWeights;
		[JsonInclude] public Dictionary<StepType, HashSet<StepType>> StepTypeReplacements;
		[JsonInclude] public CopyBehavior NonChartFileCopyBehavior = CopyBehavior.DoNotCopy;

		[JsonInclude] public LogLevel LogLevel = LogLevel.Info;
		[JsonInclude] public bool LogToFile;
		[JsonInclude] public string LogDirectory;
		[JsonInclude] public int LogFlushIntervalSeconds;
		[JsonInclude] public int LogBufferSizeBytes;

		/// <summary>
		/// Normalized DesiredArrowWeights.
		/// Values sum to 1.0.
		/// </summary>
		private Dictionary<string, List<double>> DesiredArrowWeightsNormalized;
		/// <summary>
		/// Cached value for whether the output directory is the same as the input directory.
		/// </summary>
		private bool OutputDirectoryEqualsDirectory = false;

		/// <summary>
		/// Loads the Config from the config json file.
		/// </summary>
		/// <returns>Config Instance.</returns>
		public static async Task<Config> Load()
		{
			if (Instance != null)
				return Instance;
			
			var options = new JsonSerializerOptions
			{
				Converters =
				{
					new JsonStringEnumConverter(JsonNamingPolicy.CamelCase)
				},
				ReadCommentHandling = JsonCommentHandling.Skip,
				AllowTrailingCommas = true,
				IncludeFields = true,
			};

			try
			{
				using (FileStream openStream = File.OpenRead(Fumen.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, FileName)))
				{
					Instance = await JsonSerializer.DeserializeAsync<Config>(openStream, options);
					Instance?.Init();
				}
			}
			catch (Exception e)
			{
				LogError($"Failed to load {FileName}. {e}");
				Instance = null;
			}
			return Instance;
		}

		/// <summary>
		/// Post Load initialization.
		/// </summary>
		private void Init()
		{
			// Initialize normalized weights.
			if (DesiredArrowWeights != null)
			{
				DesiredArrowWeightsNormalized = new Dictionary<string, List<double>>();
				foreach (var entry in DesiredArrowWeights)
				{
					DesiredArrowWeightsNormalized[entry.Key] = new List<double>();
					var sum = 0;
					foreach (var weight in entry.Value)
						sum += weight;
					foreach (var weight in entry.Value)
						DesiredArrowWeightsNormalized[entry.Key].Add((double) weight / sum);
				}
			}

			// Convert paths to absolute paths.
			if (!string.IsNullOrEmpty(OutputDirectory))
				OutputDirectory = System.IO.Path.GetFullPath(OutputDirectory);
			if (!string.IsNullOrEmpty(InputDirectory))
				InputDirectory = System.IO.Path.GetFullPath(InputDirectory);

			// Cache whether the output and input directories are the same.
			OutputDirectoryEqualsDirectory =
				InputDirectory != null
				&& OutputDirectory != null
				&& InputDirectory.Equals(OutputDirectory);
		}

		/// <summary>
		/// Performs validation of Config options.
		/// Will log errors and warnings.
		/// Returns true if no errors were found.
		/// </summary>
		/// <param name="supportedInputTypes">
		/// ChartTypes that are supported as valid input types.
		/// </param>
		/// <param name="supportedOutputTypes">
		/// ChartTypes that are supported as valid output types.
		/// </param>
		/// <returns>True of no errors were found and false otherwise.</returns>
		public bool Validate(List<string> supportedInputTypes, List<string> supportedOutputTypes)
		{
			var errors = false;

			if (string.IsNullOrEmpty(InputDirectory))
			{
				LogError("No InputDirectory specified.");
				errors = true;
			}
			if (string.IsNullOrEmpty(InputNameRegex))
			{
				LogError("No InputNameRegex specified.");
				errors = true;
			}
			if (string.IsNullOrEmpty(InputChartType))
			{
				LogError("No InputChartType specified.");
				errors = true;
			}
			if (!supportedInputTypes.Contains(InputChartType))
			{
				LogError($"Unsupported InputChartType \"{InputChartType}\" found. Expected value in [{string.Join(", ", supportedInputTypes)}].");
				errors = true;
			}

			if (OutputVisualizations && string.IsNullOrEmpty(VisualizationsDirectory))
			{
				LogError("OutputVisualizations is true, but no VisualizationsDirectory specified.");
				errors = true;
			}

			if (string.IsNullOrEmpty(OutputDirectory))
			{
				LogError("No OutputDirectory specified.");
				errors = true;
			}
			if (string.IsNullOrEmpty(DifficultyRegex))
			{
				LogError("No DifficultyRegex specified.");
				errors = true;
			}
			if (string.IsNullOrEmpty(OutputChartType))
			{
				LogError("No OutputChartType specified.");
				errors = true;
			}
			if (OutputChartType != null)
			{
				if (!supportedOutputTypes.Contains(OutputChartType))
				{
					LogError($"Unsupported OutputChartType \"{OutputChartType}\" found. Expected value in [{string.Join(", ", supportedOutputTypes)}].");
					errors = true;
				}

				var smChartTypeValid = SMCommon.TryGetChartType(OutputChartType, out var smChartType);
				if (!smChartTypeValid)
				{
					LogError($"OutputChartType \"{OutputChartType}\" is not a valid stepmania chart type.");
					errors = true;
				}

				var desiredWeightsValid = DesiredArrowWeights != null && DesiredArrowWeights.ContainsKey(OutputChartType);
				if (!desiredWeightsValid)
				{
					LogError($"No DesiredArrowWeights specified for \"{OutputChartType}\".");
					errors = true;
				}
				
				if (smChartTypeValid && desiredWeightsValid)
				{
					var expectedNumArrows = SMCommon.Properties[(int) smChartType].NumInputs;
					if (DesiredArrowWeights[OutputChartType].Count != expectedNumArrows)
					{
						LogError($"DesiredArrowWeights[\"{OutputChartType}\"] has {DesiredArrowWeights[OutputChartType].Count} entries. Expected {expectedNumArrows}.");
						errors = true;
					}

					foreach (var weight in DesiredArrowWeights[OutputChartType])
					{
						if (weight < 0)
						{
							LogError($"Negative weight \"{weight}\" in DesiredArrowWeights[\"{OutputChartType}\"].");
							errors = true;
						}
					}
				}
			}

			// Warn on any missing StepTypeReplacements.
			var stepTypes = Enum.GetValues(typeof(StepType)).Cast<StepType>().ToList();
			foreach (var stepType in stepTypes)
			{
				if (!StepTypeReplacements.ContainsKey(stepType) || StepTypeReplacements[stepType].Count == 0)
					LogWarn($"No StepTypeReplacements for \"{stepType:G}\"."
					        + " Steps of this type will ignored when generating Performed Charts."
					        + " This will likely result in a failures to generate Performed Charts."
					        + " To ignore this type of step, include an entry for it in StepTypeReplacements and map"
					        + " it to a type of step to use as a replacement.");
			}

			if (LogToFile)
			{
				if (string.IsNullOrEmpty(LogDirectory))
				{
					LogError("LogToFile is true, but no LogDirectory specified.");
					errors = true;
				}

				if (LogBufferSizeBytes <= 0)
				{
					LogError("Expected a non-negative LogBufferSizeBytes.");
					errors = true;
				}
			}

			return !errors;
		}

		/// <summary>
		/// Returns whether the output directory is the same as the input directory.
		/// </summary>
		/// <returns>Whether the output directory is the same as the input directory</returns>
		public bool IsOutputDirectorySameAsInputDirectory()
		{
			return OutputDirectoryEqualsDirectory;
		}

		/// <summary>
		/// Gets the desired arrow weights for the output chart type.
		/// Values normalized to sum to 1.0.
		/// </summary>
		/// <returns>List of normalized weights.</returns>
		public List<double> GetOutputDesiredArrowWeightsNormalized()
		{
			// Validation already ensures this key is present.
			return DesiredArrowWeightsNormalized[OutputChartType];
		}

		/// <summary>
		/// Determines whether the difficulty represented by the given string
		/// matches the Config DifficultyRegex.
		/// </summary>
		/// <param name="difficulty">String representing the difficulty to check.</param>
		/// <returns>True if this difficulty matches and false otherwise.</returns>
		public bool DifficultyMatches(string difficulty)
		{
			var matches = false;
			try
			{
				matches = Regex.IsMatch(difficulty, DifficultyRegex, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
			}
			catch (Exception e)
			{
				LogError($"Failed to determine if difficulty \"{difficulty}\" matches DifficultyRegex \"{DifficultyRegex}\". {e}");
			}
			return matches;
		}

		/// <summary>
		/// Determines whether the file name represented by the given string
		/// matches the Config InputNameRegex.
		/// </summary>
		/// <param name="inputFileName">String representing the input file name to check.</param>
		/// <returns>True if this file name matches and false otherwise.</returns>
		public bool InputNameMatches(string inputFileName)
		{
			var matches = false;
			try
			{
				matches = Regex.IsMatch(inputFileName, InputNameRegex, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
			}
			catch (Exception e)
			{
				LogError($"Failed to determine if file \"{inputFileName}\" matches InputNameRegex \"{InputNameRegex}\". {e}");
			}
			return matches;
		}

		#region Logging
		private static void LogError(string message)
		{
			Logger.Error($"[{LogTag}] {message}");
		}

		private static void LogWarn(string message)
		{
			Logger.Warn($"[{LogTag}] {message}");
		}

		private static void LogInfo(string message)
		{
			Logger.Info($"[{LogTag}] {message}");
		}
		#endregion Logging
	}
}
