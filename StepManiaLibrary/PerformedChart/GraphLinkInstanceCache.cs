using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using Fumen;
using static StepManiaLibrary.Constants;

namespace StepManiaLibrary.PerformedChart
{
	/// <summary>
	/// Cache of acceptable GraphLinkInstances that can be used as replacements for other GraphLinkInstances based
	/// on StepTypeFallbacks which define acceptable fallback StepTypes for each StepType.
	/// This allows for falling back to the most appropriate other StepTypes when the original StepType can't be used
	/// when generating a PerformedChart. These StepTypes are ordered from most preferable to least preferable.
	/// Given that steps can involve multiple feet, multiple portions per foot, and multiple FootAction types, the
	/// actual generation of replacement GraphLinkInstances for a given GraphLinkInstance is somewhat expensive.
	/// This class offers a thread-safe memoized method for getting these replacement GraphLinkInstance lists.
	/// The replacement lists generated by this class include Blank GraphLinkInstances which can be used as a last
	/// resort when no actual step will work.
	/// Expected Usage:
	///  Call GetGraphLinks as needed.
	/// </summary>
	internal class GraphLinkInstanceCache
	{
		/// <summary>
		/// Custom Comparer for replacement GraphLinkInstances.
		/// </summary>
		private class ReplacementGraphLinkComparer : IComparer<GraphLinkInstance>
		{
			private GraphLink SourceLink;
			private StepTypeFallbacks Fallbacks;

			public ReplacementGraphLinkComparer(GraphLink sourceLink, StepTypeFallbacks fallbacks)
			{
				SourceLink = sourceLink;
				Fallbacks = fallbacks;
			}

			public int Compare(GraphLinkInstance l1, GraphLinkInstance l2)
			{
				if (l1.Equals(l2))
					return 0;

				// Completely blank links are the worst option as they result in completely skipping steps.
				var l1Blank = l1.GraphLink.IsBlank();
				var l2Blank = l2.GraphLink.IsBlank();
				if (l1Blank != l2Blank)
					return l1Blank ? 1 : -1;

				double l1LCost = 0.0;
				double l1RCost = 0.0;
				double l2LCost = 0.0;
				double l2RCost = 0.0;

				var sourceLHasAnyValid = false;
				var sourceRHasAnyValid = false;

				var l1LHasAnyValid = false;
				var l1RHasAnyValid = false;

				var l2LHasAnyValid = false;
				var l2RHasAnyValid = false;

				var numL1StepsDropped = 0;
				var numL2StepsDropped = 0;

				for (var p = 0; p < NumFootPortions; p++)
				{
					if (SourceLink.Links[L, p].Valid)
					{
						var numFallbacks = Fallbacks.GetFallbacks(SourceLink.Links[L, p].Step).Count();
						sourceLHasAnyValid = true;

						if (!l1.GraphLink.Links[L, p].Valid)
							numL1StepsDropped++;
						else
							l1LHasAnyValid = true;
						if (!l2.GraphLink.Links[L, p].Valid)
							numL2StepsDropped++;
						else
							l2LHasAnyValid = true;

						if (l1LCost.DoubleEquals(0.0) && l1.GraphLink.Links[L, p].Valid)
							l1LCost = (double)Fallbacks.GetFallbackIndex(SourceLink.Links[L, p].Step, l1.GraphLink.Links[L, p].Step) / numFallbacks;
						if (l2LCost.DoubleEquals(0.0) && l2.GraphLink.Links[L, p].Valid)
							l2LCost = (double)Fallbacks.GetFallbackIndex(SourceLink.Links[L, p].Step, l2.GraphLink.Links[L, p].Step) / numFallbacks;
					}
					if (SourceLink.Links[R, p].Valid)
					{
						var numFallbacks = Fallbacks.GetFallbacks(SourceLink.Links[R, p].Step).Count();
						sourceRHasAnyValid = true;

						if (!l1.GraphLink.Links[R, p].Valid)
							numL1StepsDropped++;
						else
							l1RHasAnyValid = true;
						if (!l2.GraphLink.Links[R, p].Valid)
							numL2StepsDropped++;
						else
							l2RHasAnyValid = true;

						if (l1RCost.DoubleEquals(0.0) && l1.GraphLink.Links[R, p].Valid)
							l1RCost = (double)Fallbacks.GetFallbackIndex(SourceLink.Links[R, p].Step, l1.GraphLink.Links[R, p].Step) / numFallbacks;
						if (l2RCost.DoubleEquals(0.0) && l2.GraphLink.Links[R, p].Valid)
							l2RCost = (double)Fallbacks.GetFallbackIndex(SourceLink.Links[R, p].Step, l2.GraphLink.Links[R, p].Step) / numFallbacks;
					}
				}

				// Dropping a single foot is next worst.
				var l1DroppedFoot = ((sourceLHasAnyValid && !l1LHasAnyValid) || (sourceRHasAnyValid && !l1RHasAnyValid));
				var l2DroppedFoot = ((sourceLHasAnyValid && !l2LHasAnyValid) || (sourceRHasAnyValid && !l2RHasAnyValid));
				if (l1DroppedFoot != l2DroppedFoot)
					return l1DroppedFoot ? 1 : -1;

				// Steps which reduce the number of arrows are next worst.
				var comparison = numL1StepsDropped.CompareTo(numL2StepsDropped);
				if (comparison != 0)
					return comparison;

				// If there is no difference in the number of dropped steps, sort by how far away we are from the ideal step.
				comparison = (l1LCost + l1RCost).CompareTo(l2LCost + l2RCost);
				if (comparison != 0)
					return comparison;

				// Tie break on left foot cost.
				comparison = l1LCost.CompareTo(l2LCost);
				return comparison;
			}

			int IComparer<GraphLinkInstance>.Compare(GraphLinkInstance l1, GraphLinkInstance l2)
			{
				return Compare(l1, l2);
			}
		}

		/// <summary>
		/// Cache of GraphLinkInstance to all replacement GraphLinkInstances which can be used in a PerformedChart
		/// based on the StepTypeFallbacks.
		/// </summary>
		private readonly ConcurrentDictionary<StepTypeFallbacks, ConcurrentDictionary<GraphLinkInstance, List<GraphLinkInstance>>> Cache;

		/// <summary>
		/// Constructor.
		/// </summary>
		public GraphLinkInstanceCache()
		{
			Cache = new ConcurrentDictionary<StepTypeFallbacks, ConcurrentDictionary<GraphLinkInstance, List<GraphLinkInstance>>>();
		}

		/// <summary>
		/// Finds all the valid replacement GraphLinkInstance for the given foot that can be used to
		/// replace the given GraphLinkInstance based on the given StepTypeFallbacks.
		/// Helper function for FindAllReplacementLinks.
		/// Results are a list of GraphLinkInstance with only one foot's worth of data set.
		/// Results are unsorted.
		/// </summary>
		/// <param name="foot">Foot.</param>
		/// <param name="sourceLink">Original GraphLinkInstance.</param>
		/// <param name="fallbacks">StepTypeFallbacks.</param>
		/// <returns>List of all valid replacement FootArrowStates.</returns>
		private List<GraphLinkInstance> FindReplacementLinksForFoot(int foot, GraphLinkInstance sourceLink, StepTypeFallbacks fallbacks)
		{
			var stepTypeReplacements = fallbacks.GetFallbacks();
			var originalLinks = sourceLink.GraphLink.Links;
			var footLinks = new List<GraphLinkInstance>();

			for (var p = 0; p < NumFootPortions; p++)
			{
				if (!originalLinks[foot, p].Valid)
					continue;
				var originalStep = originalLinks[foot, p].Step;
				if (!stepTypeReplacements.TryGetValue(originalStep, out var newSteps))
					continue;
				var originalStepData = StepData.Steps[(int)originalStep];
				var originalBracket = originalStepData.IsBracket;
				var originalPortionToUseForNewStep = DefaultFootPortion;
				if (originalStepData.IsOneArrowBracket)
				{
					originalPortionToUseForNewStep = originalStepData.SingleStepFootPortion;
				}

				foreach (var newStep in newSteps)
				{
					var newStepData = StepData.Steps[(int)newStep];

					// Don't create invalid releases.
					if (!newStepData.CanBeUsedInRelease
						&& ((originalLinks[foot, Heel].Valid && originalLinks[foot, Heel].Action == FootAction.Release)
						|| (originalLinks[foot, Toe].Valid && originalLinks[foot, Toe].Action == FootAction.Release)))
					{
						continue;
					}

					// Single step.
					// This could be creating a step that is technically impossible. For example replacing a
					// single bracket step like BracketOneArrowToeNew from a state where you are holding with
					// your heel with a stpe like NewArrow is impossible. But it is simpler to create this
					// step and rely on there being link that matches it when searching.
					if (!newStepData.IsBracket)
					{
						// Determine the portion to use for the new step. Usually this will be
						// the DefaultFootPortion. For single arrow brackets it could be the Toe.
						var newStepFootPortion = DefaultFootPortion;
						if (newStepData.IsOneArrowBracket)
						{
							newStepFootPortion = newStepData.SingleStepFootPortion;
						}

						// Determine the portion from the original step to use for the FootAction.
						var originalPortion = originalPortionToUseForNewStep;
						if (originalBracket)
						{
							// We need to drop a step. We can drop the heel or the toe.
							// Prioritize maintaining holds.
							originalPortion = -1;
							for (var p2 = 0; p2 < NumFootPortions; p2++)
							{
								if (originalLinks[foot, p2].Action == FootAction.Hold)
								{
									originalPortion = p2;
									break;
								}
							}
							if (originalPortion == -1)
								originalPortion = DefaultFootPortion;
						}

						// Record the new state.
						var newLink = new GraphLinkInstance();
						newLink.InstanceTypes[foot, originalPortion] = sourceLink.InstanceTypes[foot, originalPortion];
						newLink.GraphLink = new GraphLink();
						newLink.GraphLink.Links[foot, newStepFootPortion] = new GraphLink.FootArrowState(newStep, originalLinks[foot, originalPortion].Action);
						footLinks.Add(newLink);
					}

					// Bracket.
					else
					{
						FootAction heelAction;
						InstanceStepType heelInstanceType;
						FootAction toeAction;
						InstanceStepType toeInstanceType;

						// Both brackets.
						if (originalBracket)
						{
							heelAction = originalLinks[foot, Heel].Action;
							heelInstanceType = sourceLink.InstanceTypes[foot, Heel];
							toeAction = originalLinks[foot, Toe].Action;
							toeInstanceType = sourceLink.InstanceTypes[foot, Toe];
						}

						// Converting a single step to a bracket.
						// This isn't normally supported and would only happen if someone is using a bizarre configuration to
						// add brackets.
						else
						{
							heelAction = originalLinks[foot, originalPortionToUseForNewStep].Action;
							heelInstanceType = sourceLink.InstanceTypes[foot, originalPortionToUseForNewStep];

							// Do not add more holds as there likely won't be future releases to release them.
							toeAction = heelAction == FootAction.Release ? FootAction.Release : FootAction.Tap;
							toeInstanceType = InstanceStepType.Default;
						}

						// Add a new state with matching heel and toe actions.
						var newLink = new GraphLinkInstance();
						newLink.InstanceTypes[foot, Heel] = heelInstanceType;
						newLink.InstanceTypes[foot, Toe] = toeInstanceType;
						newLink.GraphLink = new GraphLink();
						newLink.GraphLink.Links[foot, Heel] = new GraphLink.FootArrowState(newStep, heelAction);
						newLink.GraphLink.Links[foot, Toe] = new GraphLink.FootArrowState(newStep, toeAction);
						footLinks.Add(newLink);

						// Add another new state with swapped heel and toe actions if they are different.
						if (heelAction != toeAction)
						{
							newLink = new GraphLinkInstance();
							newLink.InstanceTypes[foot, Heel] = toeInstanceType;
							newLink.InstanceTypes[foot, Toe] = heelInstanceType;
							newLink.GraphLink = new GraphLink();
							newLink.GraphLink.Links[foot, Heel] = new GraphLink.FootArrowState(newStep, toeAction);
							newLink.GraphLink.Links[foot, Toe] = new GraphLink.FootArrowState(newStep, heelAction);
							footLinks.Add(newLink);
						}
					}
				}

				// In all cases, break.
				// There is a never a case where there are multiple valid distinct steps on one foot.
				break;
			}

			// Add a blank link.
			var blankLink = new GraphLinkInstance();
			blankLink.GraphLink = new GraphLink();
			footLinks.Add(blankLink);

			return footLinks;
		}

		/// <summary>
		/// Given a GraphLink from an ExpressedChart, find and return all acceptable GraphLinks that can
		/// be used in its place in the PerformedChart according to the given StepTypeFallbacks.
		/// </summary>
		/// <param name="sourceLink">Original GraphLink.</param>
		/// <param name="fallbacks">StepTypeFallbacks.</param>
		/// <returns>List of all valid GraphLink replacements sorted by how good they are.</returns>
		private List<GraphLinkInstance> FindAllReplacementLinks(GraphLinkInstance sourceLink, StepTypeFallbacks fallbacks)
		{
			var replacementLinks = new List<GraphLinkInstance>();
			if (sourceLink == null || sourceLink.GraphLink.IsBlank())
				return replacementLinks;

			// Accumulate links for each foot.
			var leftLinks = FindReplacementLinksForFoot(L, sourceLink, fallbacks);
			var rightLinks = FindReplacementLinksForFoot(R, sourceLink, fallbacks);

			if (leftLinks.Count == 0 && rightLinks.Count == 0)
				return replacementLinks;

			var sourceStepsWithL = false;
			var sourceStepsWithR = false;
			for (var f = 0; f < NumFeet; f++)
			{
				for (var p = 0; p < NumFootPortions; p++)
				{
					if (sourceLink.GraphLink.Links[f, p].Valid)
					{
						if (f == L)
							sourceStepsWithL = true;
						else
							sourceStepsWithR = true;
					}
				}
			}

			// Left foot step.
			if (sourceStepsWithL && !sourceStepsWithR)
			{
				replacementLinks.AddRange(leftLinks);
			}
			// Right foot step.
			else if (sourceStepsWithR && !sourceStepsWithL)
			{
				replacementLinks.AddRange(rightLinks);
			}
			// Jump.
			else
			{
				foreach (var leftLink in leftLinks)
				{
					// Do not include steps which can't be used in jumps.
					var invalidJump = false;
					for (var p = 0; p < NumFootPortions; p++)
					{
						if (leftLink.GraphLink.Links[L, p].Valid && !StepData.Steps[(int)leftLink.GraphLink.Links[L, p].Step].CanBeUsedInJump)
						{
							invalidJump = true;
							break;
						}
					}
					if (invalidJump)
						continue;

					foreach (var rightLink in rightLinks)
					{
						// Do not include steps which can't be used in jumps.
						invalidJump = false;
						for (var p = 0; p < NumFootPortions; p++)
						{
							if (rightLink.GraphLink.Links[R, p].Valid && !StepData.Steps[(int)rightLink.GraphLink.Links[R, p].Step].CanBeUsedInJump)
							{
								invalidJump = true;
								break;
							}
						}
						if (invalidJump)
							continue;

						var newLink = new GraphLinkInstance();
						newLink.GraphLink = new GraphLink();
						for (var p = 0; p < NumFootPortions; p++)
						{
							newLink.GraphLink.Links[L, p] = leftLink.GraphLink.Links[L, p];
							newLink.InstanceTypes[L, p] = leftLink.InstanceTypes[L, p];
							newLink.GraphLink.Links[R, p] = rightLink.GraphLink.Links[R, p];
							newLink.InstanceTypes[R, p] = rightLink.InstanceTypes[R, p];
						}
						replacementLinks.Add(newLink);
					}
				}
			}

			// Sort. Better options should come first.
			replacementLinks.Sort(new ReplacementGraphLinkComparer(sourceLink.GraphLink, fallbacks));
			return replacementLinks;
		}

		private static ConcurrentDictionary<GraphLinkInstance, List<GraphLinkInstance>> CreateCache(StepTypeFallbacks fallbacks)
		{
			return new ConcurrentDictionary<GraphLinkInstance, List<GraphLinkInstance>>();
		}

		/// <summary>
		/// Given a GraphLinkInstance, return all acceptable GraphLinkInstances that can be used
		/// in its place in the PerformedChart according to the given StepTypeFallbacks.
		/// This function can involve some heavy loops depending on how deep the StepTypeFallbacks
		/// are and how many valid foot portions are present in the given link.
		/// Results are cached for the given StepTypeFallbacksg and source link so subsequent call
		/// with the same parameters return with an O(1) lookup.
		/// Thread-safe.
		/// </summary>
		/// <param name="sourceLink">Original GraphLinkInstance.</param>
		/// <param name="fallbacks">StepTypeFallbacks.</param>
		/// <returns>
		/// List of all valid GraphLinkInstance replacements sorted by how good they are.
		/// This will include Blank GraphLinkInstances.
		/// </returns>
		public List<GraphLinkInstance> GetGraphLinks(GraphLinkInstance sourceLink, StepTypeFallbacks fallbacks)
		{
			if (fallbacks == null)
			{
				// It is faster in practice to allocate a new list and return it than it is to cache it when needing
				// to be thread-safe.
				return new List<GraphLinkInstance>(1) { sourceLink };
			}

			var cacheForFallbacks = Cache.GetOrAdd(fallbacks, CreateCache);
			return cacheForFallbacks.GetOrAdd(sourceLink, FindAllReplacementLinks, fallbacks);
		}

		/// <summary>
		/// Returns whether the given replacement GraphLinkInstance replaces any valid foot action
		/// with a blank link from the given source GraphLinkInstance.
		/// </summary>
		/// <param name="sourceLink">Source GraphLinkInstance.</param>
		/// <param name="replacementLink">Replacement GraphLinkInstance.</param>
		/// <returns>True of the replacement contains a Blank link where the source does not.</returns>
		public bool ContainsBlankLink(GraphLinkInstance sourceLink, GraphLinkInstance replacementLink)
		{
			for (var f = 0; f < NumFeet; f++)
			{
				var sourceFootValid = false;
				var replacementFootValid = false;
				for (var p = 0; p < NumFootPortions; p++)
				{
					if (sourceLink.GraphLink.Links[f, p].Valid)
						sourceFootValid = true;
					if (replacementLink.GraphLink.Links[f, p].Valid)
						replacementFootValid = true;
				}
				if (sourceFootValid && !replacementFootValid)
					return true;
			}
			return false;
		}

		/// <summary>
		/// Returns the total number of steps removed from the given source GraphLinkInstance when it
		/// is replaced by the given replacement GraphLinkInstance.
		/// </summary>
		/// <param name="sourceLink">Source GraphLinkInstance.</param>
		/// <param name="replacementLink">Replacement GraphLinkInstance.</param>
		/// <returns>
		/// Total number of steps removed from the given source GraphLinkInstance when it is replaced
		/// by the given replacement GraphLinkInstance.
		/// </returns>
		public int GetNumStepsRemoved(GraphLinkInstance sourceLink, GraphLinkInstance replacementLink)
		{
			var numStepsRemoved = 0;
			for (var f = 0; f < NumFeet; f++)
			{
				for (var p = 0; p < NumFootPortions; p++)
				{
					if (sourceLink.GraphLink.Links[f, p].Valid && !replacementLink.GraphLink.Links[f, p].Valid)
					{
						numStepsRemoved++;
					}
				}
			}
			return numStepsRemoved;
		}
	}
}
