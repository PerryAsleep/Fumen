how do patterns? like 123412341234...
	Separate structure in Expressed charts that map a range of stepevents to another range.
		ranges that are longer (e.g. a repeated 16 note pattern) are more important to repeat

Way to express preference
	e.g. RLR as 523 is less preferable than RLR as 524


Logic:
	X initialize dp arrow data
	- initialize dp graph

	- load sp chart
	- convert sp chart to expressed chart

	X search for a path through the dp graph that matches the expressed chart
	- put the mines in
	- convert the path to a dp chart
	- put all the tempo changes, stops in

SP algorithm:
	examining current event, have a group of leaves from a search tree.
	for all leaves:
		1) pick ALL choices out of this node
			1a) assign weights:
			1b) weight assignment need to know things like mines and and which foot was released most recently
				this is so we can look at a LR jump where L is a short hold, and the next note is D but we know you should step with R instead of L (L weight is higher)
		2) eliminate choices which do not result in this state.
	update leaves to be new leaves
	3) look at all leaves and for any with a matching state, eliminate the most expensive
	4) when eliminating, prune parent up until a node that shares an unpruned path.


Memory:
	need to kill recursion
	bfs?
	do the first node, but don't recurse. just continue to find all links out of it to new nodes. do this until complete.
	while(any child is not fully done)
	{
		foreach(child)
			fillnode(child)

		children = sum of all children of current child nodes
		remove those children which are fully done.
	}


look at Hella Deep in Technical Showcase 4 - crazy bpm stuff
NewAlone has roll chord
Primitive Vides - LR hold, alternate jacks on down 

Space:

	How many nodes are there?
		SP
			4 arrows, 7 GraphArrowState: 7 ^ 4 = 2401
		DP
			8 arrows, 7 GraphArrowState: 7 ^ 8 = 5764801

	this is a problem because the graph generation is recursive

	How many links per node?




























var stepTypes = Enum.GetValues(typeof(StepType)).Cast<StepType>();
			foreach (var stepType in stepTypes)
			{
				switch (stepType)
				{
					// Left foot steps on a new arrow.
					case StepType.LNewArrow:
					case StepType.LDoubleStep:
					{
						// Left foot cannot step on a new arrow if it is currently on a hold.
						// This would be considered a LBracketNewArrow.
						if (currentNode.State.Any(s => s == GraphArrowState.LHeld))
							break;

						// Loop over every arrow resting under the left foot.
						for (var currentLIndex = 0; currentLIndex < numArrows; currentLIndex++)
						{
							if (currentNode.State[currentLIndex] != GraphArrowState.LResting)
								continue;

							// Loop over the arrows to find a new valid left foot placement.
							for (var newLIndex = 0; newLIndex < numArrows; newLIndex++)
							{
								// Skip if this isn't a valid next arrow for the current placement.
								if (!arrowData[currentLIndex].ValidNextArrows[newLIndex])
									continue;
								// Skip if this next arrow is occupied.
								if (currentNode.State[newLIndex] != GraphArrowState.Free)
									continue;
								// Skip if this next arrow is a crossover with any right foot arrow.
								if (currentNode.LeftCrossesOver(arrowData, newLIndex))
									continue;
								// Skip if this next arrow is not a valid pairing for a right foot arrow.
								if (!currentNode.IsValidLeftPairing(arrowData, newLIndex))
									continue;

								var footActions = Enum.GetValues(typeof(FootAction)).Cast<FootAction>();
								foreach (var footAction in footActions)
								{
									// Set up the state for a new node
									var newState = new GraphArrowState[numArrows];
									for (var newIndex = 0; newIndex < numArrows; newIndex++)
									{
										newState[newIndex] = currentNode.State[newIndex];
										if (newState[newIndex] == GraphArrowState.LResting)
											newState[newIndex] = GraphArrowState.Free;
									}

									switch (footAction)
									{
										case FootAction.Tap:
										{
											newState[newLIndex] = GraphArrowState.LResting;
											break;
										}
										case FootAction.Hold:
										{
											newState[newLIndex] = GraphArrowState.LHeld;
											break;
										}
										case FootAction.Roll:
										{
											newState[newLIndex] = GraphArrowState.LRolling;
											break;
										}
										// Cannot release on a new arrow.
										case FootAction.Release:
										default:
											continue;
									}

									// Link the current node to the new node for the new state and recurse.
									AddNodeAndRecurse(currentNode, visitedNodes, stepType, newState, footAction, arrowData);
								}
							}
						}

						break;
					}

					case StepType.LSameArrow:
					{
						if (footAction == FootAction.Tap || footAction == FootAction.Hold)
						{
							// Left foot cannot step on the same arrow if it is currently on a hold.
							// This would be considered a LBracketSameArrow.
							if (currentNode.State.Any(s => s == GraphArrowState.LHeld))
								break;

							// Loop over every arrow resting under the left foot.
							for (var currentLIndex = 0; currentLIndex < numArrows; currentLIndex++)
							{
								if (currentNode.State[currentLIndex] != GraphArrowState.LResting)
									continue;

								// Set up the state for a new node
								var newState = new GraphArrowState[numArrows];
								for (var newIndex = 0; newIndex < numArrows; newIndex++)
								{
									newState[newIndex] = currentNode.State[newIndex];
									if (newState[newIndex] == GraphArrowState.LResting)
										newState[newIndex] = GraphArrowState.Free;
								}

								newState[currentLIndex] = footAction == FootAction.Tap
									? GraphArrowState.LResting
									: GraphArrowState.LHeld;

								// Link the current node to the new node for the new state and recurse.
								AddNodeAndRecurse(currentNode, visitedNodes, stepType, newState, arrowData);
							}
						}
						else
						{
							// Loop over every arrow resting under the left foot.
							for (var currentLIndex = 0; currentLIndex < numArrows; currentLIndex++)
							{
								// If the arrow is held, it can be released.
								if (currentNode.State[currentLIndex] != GraphArrowState.LHeld)
									continue;

								// Set up the state for a new node
								var newState = new GraphArrowState[numArrows];
								for (var newIndex = 0; newIndex < numArrows; newIndex++)
								{
									newState[newIndex] = currentNode.State[newIndex];
								}
								newState[currentLIndex] = GraphArrowState.LResting;

								// Link the current node to the new node for the new state and recurse.
								AddNodeAndRecurse(currentNode, visitedNodes, stepType, newState, arrowData);
							}
						}
						break;
					}

					default:
						break;
				}
			}





































					BracketablePairings =
					{
						// Left foot on P1L is bracketable with P1U and P1D
						[l] = FromDP(new[] {P1D, P1U}),
						// Right foot on P1L is a crossover and not bracketable
						[r] = noneDP
					},

\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsRCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	L other same front		1 2
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsRCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	L other same behind		3 4
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsLCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	L other other front		5 6
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsLCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	L other other behind	7 8

\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsRCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	R other same front		9 10
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsRCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	R other same behind		11 12
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsLCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	R other other front		13 14
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsLCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n	R other other behind	15 16


\t\t\t\t\tOtherFootPairingsSameFootCrossoverFront =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$5\r\n\t\t\t\t\t\t[l] = $6,\r\n\t\t\t\t\t\t$9\r\n\t\t\t\t\t\t[r] = $10\r\n\t\t\t\t\t},\r\n
\t\t\t\t\tOtherFootPairingsSameFootCrossoverBehind =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$7\r\n\t\t\t\t\t\t[l] = $8,\r\n\t\t\t\t\t\t$11\r\n\t\t\t\t\t\t[r] = $12\r\n\t\t\t\t\t},\r\n
\t\t\t\t\tOtherFootPairingsOtherFootCrossoverFront =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$1\r\n\t\t\t\t\t\t[l] = $2,\r\n\t\t\t\t\t\t$13\r\n\t\t\t\t\t\t[r] = $14\r\n\t\t\t\t\t},\r\n
\t\t\t\t\tOtherFootPairingsOtherFootCrossoverBehind =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$3\r\n\t\t\t\t\t\t[l] = $4,\r\n\t\t\t\t\t\t$15\r\n\t\t\t\t\t\t[r] = $16\r\n\t\t\t\t\t},\r\n

Regex:
\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsRCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsRCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsLCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tRPairingsLCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsRCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsRCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsLCrossoverFront = ([a-zA-Z\(\)\[\]\{\} 0-9,]*),\r\n\t\t\t\t\t(// [a-zA-Z0-9 ,.]*)\r\n\t\t\t\t\tLPairingsLCrossoverBehind = ([a-zA-Z\(\)\[\]\{\} 0-9,]*)\r\n
\t\t\t\t\tOtherFootPairingsSameFootCrossoverFront =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$5\r\n\t\t\t\t\t\t[l] = $6,\r\n\t\t\t\t\t\t$9\r\n\t\t\t\t\t\t[r] = $10\r\n\t\t\t\t\t},\r\n\t\t\t\t\tOtherFootPairingsSameFootCrossoverBehind =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$7\r\n\t\t\t\t\t\t[l] = $8,\r\n\t\t\t\t\t\t$11\r\n\t\t\t\t\t\t[r] = $12\r\n\t\t\t\t\t},\r\n\t\t\t\t\tOtherFootPairingsOtherFootCrossoverFront =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$1\r\n\t\t\t\t\t\t[l] = $2,\r\n\t\t\t\t\t\t$13\r\n\t\t\t\t\t\t[r] = $14\r\n\t\t\t\t\t},\r\n\t\t\t\t\tOtherFootPairingsOtherFootCrossoverBehind =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t$3\r\n\t\t\t\t\t\t[l] = $4,\r\n\t\t\t\t\t\t$15\r\n\t\t\t\t\t\t[r] = $16\r\n\t\t\t\t\t},\r\n














// P1D
				new ArrowData
				{
					Position = P1D,

					// A foot on P1D can move next to P1L, P1U, P1R, or P2L
					ValidNextArrows = FromDP(new[] {P1L, P1U, P1R, P2L}),

					BracketablePairings =
					{
						// Left foot on P1D is bracketable with P1L and P1R
						[l] = FromDP(new[] {P1L, P1R}),
						// Right foot on P1D is bracketable with P1R
						[r] = FromDP(new[] {P1R})
					},

					OtherFootPairings =
					{
						// Left foot on P1D supports right foot on P1U, P1R, and P2L without crossovers
						[l] = FromDP(new[] {P1U, P1R, P2L}),
						// Right foot on P1D supports Left foot on P1L and P1U without crossovers
						[r] = FromDP(new[] {P1L, P1U})
					},

					// Left foot on P1D is a crossover with right in front with right is on P1L
					RPairingsRCrossoverFront = FromDP(new[] {P1L}),
					// none
					RPairingsRCrossoverBehind = noneDP,
					// none
					RPairingsLCrossoverFront = noneDP,
					// Left foot on P1D is a crossover with left in back with right is on P1L
					RPairingsLCrossoverBehind = FromDP(new[] {P1L}),
					// Right foot on P1D is not a crossover with right in front
					LPairingsRCrossoverFront = noneDP,
					// Right foot on P1D is a crossover with right in back when left is on P1R
					LPairingsRCrossoverBehind = FromDP(new[] {P1R}),
					// Right foot on P1D is a crossover with left in front when left is on P1R
					LPairingsLCrossoverFront = FromDP(new[] {P1R}),
					// Right foot on P1D is not a crossover with left in back
					LPairingsLCrossoverBehind = noneDP
				},

				// P1U
				new ArrowData
				{
					Position = P1U,

					// A foot on P1U can move next to P1L, P1D, P1R, or P2L
					ValidNextArrows = FromDP(new[] {P1L, P1D, P1R, P2L}),

					BracketablePairings =
					{
						// Left foot on P1U is bracketable with P1L and P1R
						[l] = FromDP(new[] {P1L, P1R}),
						// Right foot on P1U is bracketable with P1R
						[r] = FromDP(new[] {P1R})
					},

					OtherFootPairings =
					{
						// Left foot on P1U supports right foot on P1D, P1R, and P2L without crossovers
						[l] = FromDP(new[] {P1D, P1R, P2L}),
						// Right foot on P1U supports left foot on P1L and P1D without crossovers
						[r] = FromDP(new[] {P1L, P1D})
					},

					// none
					RPairingsRCrossoverFront = noneDP,
					// Left foot on P1U is a crossover with right in back when right is on P1L
					RPairingsRCrossoverBehind = FromDP(new[] {P1L}),
					// Left foot on P1U is a crossover with left in front when right is on P1L
					RPairingsLCrossoverFront = FromDP(new[] {P1L}),
					// none
					RPairingsLCrossoverBehind = noneDP,
					// Right foot on P1U is a crossover with right in front when left is on P1R
					LPairingsRCrossoverFront = FromDP(new[] {P1R}),
					// none
					LPairingsRCrossoverBehind = noneDP,
					// none
					LPairingsLCrossoverFront = noneDP,
					// Right foot on P1U is a crossover with left in back when left is on P1R
					LPairingsLCrossoverBehind = FromDP(new[] {P1R})
				},

				// P1R
				new ArrowData
				{
					Position = P1R,

					// A foot on P1R can move next to P1L, P1D, P1U, P2L, P2D, or P2U
					ValidNextArrows = FromDP(new[] {P1L, P1D, P1U, P2L, P2D, P2U}),

					BracketablePairings =
					{
						// Left foot on P1R is bracketable with P1D, P1U, and P2R
						[l] = FromDP(new[] {P1D, P1U, P2R}),
						// Right foot on P1R is bracketable with P1D, P1U, and P2R
						[r] = FromDP(new[] {P1D, P1U, P2R})
					},

					OtherFootPairings =
					{
						// Left foot on P1R supports right foot on P2L, P2D, and P2U without crossovers
						[l] = FromDP(new[] {P2L, P2D, P2U}),
						// Right foot on P1R supports left foot on P1L, P1D, and P1U without crossovers
						[r] = FromDP(new[] {P1L, P1D, P1U})
					},

					// Left foot on P1R is a crossover with right in front when right is on P1U
					RPairingsRCrossoverFront = FromDP(new[] {P1U}),
					// Left foot on P1R is a crossover with right in back when right is on P1D
					RPairingsRCrossoverBehind = FromDP(new[] {P1D}),
					// Left foot on P1R is a crossover with left in front when right is on P1D
					RPairingsLCrossoverFront = FromDP(new[] {P1D}),
					// Left foot on P1R is a crossover with left in back when right is on P1U
					RPairingsLCrossoverBehind = FromDP(new[] {P1U}),
					// Right foot on P1R is not a crossover position. Not considering left on P2L, slightly too twisty
					LPairingsRCrossoverFront = noneDP,
					// none
					LPairingsRCrossoverBehind = noneDP,
					// none
					LPairingsLCrossoverFront = noneDP,
					// none
					LPairingsLCrossoverBehind = noneDP
				},

				// P2L
				new ArrowData
				{
					Position = P2L,

					// A foot on P2L can move next to P1D, P1U, P1R, P2D, P2U, or P2R
					ValidNextArrows = FromDP(new[] {P1D, P1U, P1R, P2D, P2U, P2R}),

					BracketablePairings =
					{
						// Left foot on P2L is bracketable with P1R, P2D, and P2U
						[l] = FromDP(new[] {P1R, P2D, P2U}),
						// Right foot on P2L is bracketable with P1R, P2D, and P2U
						[r] = FromDP(new[] {P1R, P2D, P2U})
					},

					OtherFootPairings =
					{
						// Left foot on P2L supports right foot on P2D, P2U, and P2R without crossovers
						[l] = FromDP(new[] {P2D, P2U, P2R}),
						// Right foot on P2L supports left foot on P1D, P1U, and P1L without crossovers
						[r] = FromDP(new[] {P1D, P1U, P1L})
					},

					// Left foot on P2L is not a crossover position. Not considering right on P1R, slightly too twisty
					RPairingsRCrossoverFront = noneDP,
					// none
					RPairingsRCrossoverBehind = noneDP,
					// none
					RPairingsLCrossoverFront = noneDP,
					// none
					RPairingsLCrossoverBehind = noneDP,
					// Right foot on P2L is a crossover with right in front when left is on P2D
					LPairingsRCrossoverFront = FromDP(new[] {P2D}),
					// Right foot on P2L is a crossover with right in back when left is on P2U
					LPairingsRCrossoverBehind = FromDP(new[] {P2U}),
					// Right foot on P2L is a crossover with left in front when left is on P2U
					LPairingsLCrossoverFront = FromDP(new[] {P2U}),
					// Right foot on P2L is a crossover with left in back when left is on P2D
					LPairingsLCrossoverBehind = FromDP(new[] {P2D})
				},

				// P2D
				new ArrowData
				{
					Position = P2D,

					// A foot on P2D can move next to P1R, P2L, P2U, and P2R
					ValidNextArrows = FromDP(new[] {P1R, P2L, P2U, P2R}),

					BracketablePairings =
					{
						// Left foot on P2D is bracketable with P2L
						[l] = FromDP(new[] {P2L}),
						// Right foot on P2D is bracketable with P2L and P2R
						[r] = FromDP(new[] {P2L, P2R})
					},

					OtherFootPairings =
					{
						// Left foot on P2D supports right foot on P2U and P2R without crossovers
						[l] = FromDP(new[] {P2U, P2R}),
						// Right foot on P2D supports left foot on P1R, P2L, and P2U without crossovers
						[r] = FromDP(new[] {P1R, P2L, P2U})
					},

					// Left foot on P2D is a crossover with right in front when right is on P2L
					RPairingsRCrossoverFront = FromDP(new[] {P2L}),
					// none
					RPairingsRCrossoverBehind = noneDP,
					// none
					RPairingsLCrossoverFront = noneDP,
					// Left foot on P2D is a crossover with left in back when right is on P2L
					RPairingsLCrossoverBehind = FromDP(new[] {P2L}),
					// none
					LPairingsRCrossoverFront = noneDP,
					// Right foot on P2D is a crossover with right in back when left is on P2R
					LPairingsRCrossoverBehind = FromDP(new[] {P2R}),
					// Right foot on P2D is a crossover with left in front when left is on P2R
					LPairingsLCrossoverFront = FromDP(new[] {P2R}),
					// none
					LPairingsLCrossoverBehind = noneDP
				},

				// P2U
				new ArrowData
				{
					Position = P2U,

					// A foot on P2U can move next to P1R, P2L, P2D, and P2R
					ValidNextArrows = FromDP(new[] {P1R, P2L, P2D, P2R}),

					BracketablePairings =
					{
						// Left foot on P2U is bracketable with P2L
						[l] = FromDP(new[] {P2L}),
						// Right foot on P2U is bracketable with P2L and P2R
						[r] = FromDP(new[] {P2L, P2R})
					},

					OtherFootPairings =
					{
						// Left foot on P2U supports right foot on P2D and P2R without crossovers
						[l] = FromDP(new[] {P2D, P2R}),
						// Right foot on P2U supports left foot on P1R, P2L, and P2D without crossovers
						[r] = FromDP(new[] {P1R, P2L, P2D})
					},

					// none
					RPairingsRCrossoverFront = noneDP,
					// Left foot on P2U is a crossover with right in back when right is on P2L
					RPairingsRCrossoverBehind = FromDP(new[] {P2L}),
					// Left foot on P2U is a crossover with left in front when right is on P2L
					RPairingsLCrossoverFront = FromDP(new[] {P2L}),
					// none
					RPairingsLCrossoverBehind = noneDP,
					// Right foot on P2U is a crossover with right in front when left is on P2R
					LPairingsRCrossoverFront = FromDP(new[] {P2R}),
					// none
					LPairingsRCrossoverBehind = noneDP,
					// none
					LPairingsLCrossoverFront = noneDP,
					// Right foot on P2U is a crossover with left in back when left is on P2R
					LPairingsLCrossoverBehind = FromDP(new[] {P2R})
				},

				// P2R
				new ArrowData
				{
					Position = P2R,

					// A foot on P2R can move next to P2L, P2D, and P2U
					ValidNextArrows = FromDP(new[] {P2L, P2D, P2U}),

					BracketablePairings =
					{
						// Left foot on P2R is a crossover and not bracketable
						[l] = noneDP,
						// Right foot on P2R is bracketable with P2D and P2U
						[r] = FromDP(new[] {P2D, P2U})
					},

					OtherFootPairings =
					{
						// Left foot on P2R is a crossover with no normal right foot pairing
						[l] = noneDP,
						// Right foot on P2R supports left foot on P2L, P2D, and P2U without crossovers
						[r] = FromDP(new[] {P2L, P2D, P2U})
					},

					// Left foot on P2R is a crossover with right in front when right is on P2U
					RPairingsRCrossoverFront = FromDP(new[] {P2U}),
					// Left foot on P2R is a crossover with right in back when right is on P2D
					RPairingsRCrossoverBehind = FromDP(new[] {P2D}),
					// Left foot on P2R is a crossover with left in front when right is on P2D
					RPairingsLCrossoverFront = FromDP(new[] {P2D}),
					// Left foot on P2R is a crossover with left in back when right is on P2U
					RPairingsLCrossoverBehind = FromDP(new[] {P2U}),
					// Right foot on P2R is never a crossover position
					LPairingsRCrossoverFront = noneDP,
					// none
					LPairingsRCrossoverBehind = noneDP,
					// none
					LPairingsLCrossoverFront = noneDP,
					// none
					LPairingsLCrossoverBehind = noneDP
				}
			};