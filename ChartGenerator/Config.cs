using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Fumen;
using System.Text.RegularExpressions;

namespace ChartGenerator
{
	/// <summary>
	/// Enumeration of methods for overwriting charts.
	/// </summary>
	public enum OverwriteBehavior
	{
		/// <summary>
		/// Do no overwrite charts that match the output type.
		/// </summary>
		DoNotOverwrite,
		/// <summary>
		/// Overwrite existing charts if they were generated by this program.
		/// </summary>
		IfFumenGenerated,
		/// <summary>
		/// Overwrite existing charts if they were generated by this program and they
		/// were generated at an older version.
		/// </summary>
		IfFumenGeneratedAndNewerVersion,
		/// <summary>
		/// Always overwrite any existing charts.
		/// </summary>
		Always
	}

	/// <summary>
	/// Configuration for ChartGenerator.
	/// Deserialized from json config file.
	/// </summary>
	public class Config
	{
		private const string FileName = "config.json";
		private const string LogTag = "Config";

		public static Config Instance { get; private set; }

		[JsonInclude] public string InputDirectory;
		[JsonInclude] public string InputNameRegex;
		[JsonInclude] public string InputChartType;
		[JsonInclude] public string DifficultyRegex;
		[JsonInclude] public string OutputChartType;
		[JsonInclude] public string OutputDirectory;
		[JsonInclude] public OverwriteBehavior OverwriteBehavior = OverwriteBehavior.DoNotOverwrite;
		[JsonInclude] public bool OutputVisualizations = true;
		[JsonInclude] public string VisualizationsDirectory;
		[JsonInclude] public Dictionary<StepType, HashSet<StepType>> StepTypeReplacements;
		[JsonInclude] public LogLevel LogLevel = LogLevel.Info;

		/// <summary>
		/// Loads the Config from the config json file.
		/// </summary>
		/// <returns>Config Instance.</returns>
		public static async Task<Config> Load()
		{
			if (Instance != null)
				return Instance;
			
			var options = new JsonSerializerOptions
			{
				Converters =
				{
					new JsonStringEnumConverter(JsonNamingPolicy.CamelCase)
				},
				ReadCommentHandling = JsonCommentHandling.Skip,
				AllowTrailingCommas = true,
				IncludeFields = true,
			};

			try
			{
				using (FileStream openStream = File.OpenRead($@"{AppDomain.CurrentDomain.BaseDirectory}\{FileName}"))
				{
					Instance = await JsonSerializer.DeserializeAsync<Config>(openStream, options);
				}
			}
			catch (Exception e)
			{
				LogError($"Failed to load {FileName}. {e}");
				Instance = null;
			}
			return Instance;
		}

		/// <summary>
		/// Performs validation of Config options.
		/// Will log errors and warnings and return true if no errors were found.
		/// </summary>
		/// <param name="supportedInputTypes">
		/// ChartTypes that are supported as valid input types.
		/// </param>
		/// <param name="supportedOutputTypes">
		/// ChartTypes that are supported as valid output types.
		/// </param>
		/// <returns>True of no errors were found and false otherwise.</returns>
		public bool Validate(List<string> supportedInputTypes, List<string> supportedOutputTypes)
		{
			var errors = false;

			if (string.IsNullOrEmpty(InputChartType))
			{
				LogError("No InputChartType specified.");
				errors = true;
			}
			if (!supportedInputTypes.Contains(InputChartType))
			{
				LogError($"Unsupported InputChartType \"{InputChartType}\" found. Expected value in [{string.Join(", ", supportedInputTypes)}].");
				errors = true;
			}
			if (string.IsNullOrEmpty(OutputChartType))
			{
				LogError("No OutputChartType specified.");
				errors = true;
			}
			if (!supportedOutputTypes.Contains(OutputChartType))
			{
				LogError($"Unsupported OutputChartType \"{OutputChartType}\" found. Expected value in [{string.Join(", ", supportedOutputTypes)}].");
				errors = true;
			}
			if (OutputVisualizations && string.IsNullOrEmpty(VisualizationsDirectory))
			{
				LogError("OutputVisualizations is true, but no VisualizationsDirectory specified.");
				errors = true;
			}

			// Warn on any missing StepTypeReplacements.
			var stepTypes = Enum.GetValues(typeof(StepType)).Cast<StepType>().ToList();
			foreach (var stepType in stepTypes)
			{
				if (!StepTypeReplacements.ContainsKey(stepType) || StepTypeReplacements[stepType].Count == 0)
					LogWarn($"No StepTypeReplacements for \"{stepType:G}\"."
					        + " Steps of this type will ignored when generating Performed Charts."
					        + " This will likely result in a failures to generate Performed Charts."
					        + " To ignore this type of step, include an entry for it in StepTypeReplacements and map"
					        + " it to a type of step to use as a replacement.");
			}

			return !errors;
		}

		/// <summary>
		/// Determines whether the difficulty represented by the given string
		/// matches the Config DifficultyRegex.
		/// </summary>
		/// <param name="difficulty">String representing the difficulty to check.</param>
		/// <returns>True if this difficulty matches and false otherwise.</returns>
		public bool DifficultyMatches(string difficulty)
		{
			var matches = false;
			try
			{
				matches = Regex.IsMatch(difficulty, DifficultyRegex, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
			}
			catch (Exception e)
			{
				LogError($"Failed to determine if difficulty \"{difficulty}\" matches DifficultyRegex \"{DifficultyRegex}\". {e}");
			}
			return matches;
		}

		/// <summary>
		/// Determines whether the file name represented by the given string
		/// matches the Config InputNameRegex.
		/// </summary>
		/// <param name="inputFileName">String representing the input file name to check.</param>
		/// <returns>True if this file name matches and false otherwise.</returns>
		public bool InputNameMatches(string inputFileName)
		{
			var matches = false;
			try
			{
				matches = Regex.IsMatch(inputFileName, InputNameRegex, RegexOptions.Singleline, TimeSpan.FromSeconds(1));
			}
			catch (Exception e)
			{
				LogError($"Failed to determine if file \"{inputFileName}\" matches InputNameRegex \"{InputNameRegex}\". {e}");
			}
			return matches;
		}

		#region Logging
		private static void LogError(string message)
		{
			Logger.Error($"[{LogTag}] {message}");
		}

		private static void LogWarn(string message)
		{
			Logger.Warn($"[{LogTag}] {message}");
		}

		private static void LogInfo(string message)
		{
			Logger.Info($"[{LogTag}] {message}");
		}
		#endregion Logging
	}
}
