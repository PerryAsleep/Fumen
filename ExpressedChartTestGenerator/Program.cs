using System;
using System.IO;
using System.Text;
using ChartGeneratorTests;
using Fumen.Converters;
using static StepManiaLibrary.Constants;

namespace ExpressedChartTestGenerator
{
	internal class Program
	{
		/// <summary>
		/// Generate test code to assert that an ExpressedChart matches the current state of the ExpressedChart generated from an sm file.
		/// </summary>
		/// <param name="argument">
		/// Name of the folder containing the sm file to use for the test.
		/// Expected to be in ChartGeneratorTests\TestData.
		/// </param>
		/// <param name="file">
		/// Name of the song file inside of the given folder to use for the test.
		/// </param>
		/// <param name="extension">
		/// Extension of the song file.
		/// </param>
		/// <param name="difficulty">
		/// DifficultyType of the chart within the sm file to test.
		/// </param>
		/// <param name="type">
		/// ChartType of the chart within the sm file to test.
		/// </param>
		/// <param name="fullFile">
		/// Write a new cs file containing the full test for the chart.
		/// Otherwise log the test as a method to the console to be copied.
		/// </param>
		public static void Main(
			string argument,
			string file = "test",
			string extension = "sm",
			string type = "dance-single",
			string difficulty = "Beginner",
			bool fullFile = false)
		{
			GenerateTest(argument, file, extension, type, difficulty, fullFile);
		}

		private static void GenerateTest(string folder, string file, string extension, string chartType, string chartDifficultyType, bool fullFile)
		{
			if (!SMCommon.TryGetChartType(chartType, out var smChartType))
			{
				Console.WriteLine($"Could not parse ChartType: '{chartType}'.");
				return;
			}

			var filePath = TestExpressedChart.GetTestChartPath(folder, file, extension);
			var ec = TestExpressedChart.Load(filePath, chartDifficultyType, smChartType);

			string cleanedFileName;
			if (file == "test")
				cleanedFileName = folder.Replace(" ", string.Empty);
			else
				cleanedFileName = file.Replace(" ", string.Empty);

			var sb = new StringBuilder();

			if (fullFile)
			{
				sb.AppendLine("using Microsoft.VisualStudio.TestTools.UnitTesting;");
				sb.AppendLine("using StepManiaLibrary;");
				sb.AppendLine("using Fumen.Converters;");
				sb.AppendLine("using static ChartGeneratorTests.TestExpressedChart;");
				sb.AppendLine("// ReSharper disable RedundantAssignment");
				sb.AppendLine("// ReSharper disable InconsistentNaming");
				sb.AppendLine("// ReSharper disable IdentifierTypo");
				sb.AppendLine("");
				sb.AppendLine("namespace ChartGeneratorTests");
				sb.AppendLine("{");
				sb.AppendLine("\t/// <summary>");
				sb.AppendLine($"\t/// Autogenerated test class for {folder}\\{file}.");
				sb.AppendLine("\t/// </summary>");
				sb.AppendLine("\t[TestClass]");
				sb.AppendLine($"\tpublic class {cleanedFileName}");
				sb.AppendLine("\t{");
			}

			sb.AppendLine("\t\t/// <summary>");
			sb.AppendLine($"\t\t/// Autogenerated test for {folder}\\{file}.");
			sb.AppendLine("\t\t/// </summary>");
			sb.AppendLine("\t\t[TestMethod]");
			sb.AppendLine($"\t\tpublic void Test{cleanedFileName}()");
			sb.AppendLine("\t\t{");
			sb.AppendLine($"\t\t\tvar ec = Load(GetTestChartPath(\"{folder}\", \"{file}\", \"{extension}\"), \"{chartDifficultyType}\", SMCommon.ChartType.{smChartType});");

			sb.AppendLine("");
			sb.AppendLine("\t\t\t// Step Events");
			sb.AppendLine($"\t\t\tAssert.AreEqual({ec.StepEvents.Count}, ec.StepEvents.Count);");
			if (ec.StepEvents.Count > 0)
			{
				sb.AppendLine("\t\t\tvar s = 0;");
				foreach (var se in ec.StepEvents)
				{
					sb.Append("\t\t\tAssertLinkMatchesFullInformation(ec.StepEvents[s++].LinkInstance");
					for (var f = 0; f < NumFeet; f++)
					{
						for (var p = 0; p < NumFootPortions; p++)
						{
							sb.Append(se.LinkInstance.GraphLink.Links[f, p].Valid ? ", true" : ", false");
							sb.Append(", StepType." + se.LinkInstance.GraphLink.Links[f, p].Step.ToString("G"));
							sb.Append(", FootAction." + se.LinkInstance.GraphLink.Links[f, p].Action.ToString("G"));
							sb.Append(", InstanceStepType." + se.LinkInstance.InstanceTypes[f, p].ToString("G"));
						}
					}

					sb.AppendLine(");");
				}
			}

			sb.AppendLine("");
			sb.AppendLine("\t\t\t// Mine Events");
			sb.AppendLine($"\t\t\tAssert.AreEqual({ec.MineEvents.Count}, ec.MineEvents.Count);");
			if (ec.MineEvents.Count > 0)
			{
				sb.AppendLine("\t\t\tvar m = 0;");
				foreach (var me in ec.MineEvents)
				{
					sb.Append("\t\t\tAssertMineEventMatches(ec.MineEvents[m++]");
					sb.Append(", MineType." + me.Type.ToString("G"));
					sb.Append($", {me.ArrowIsNthClosest}");
					sb.Append($", {me.FootAssociatedWithPairedNote}");
					sb.AppendLine(");");
				}
			}

			sb.AppendLine("\t\t}");

			if (fullFile)
			{
				sb.AppendLine("\t}");
				sb.AppendLine("}");
				
				File.WriteAllText(
					Fumen.Path.Combine(new [] {AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "ChartGeneratorTests", $"Test{cleanedFileName}.cs"})
					, sb.ToString());
			}
			else
			{
				Console.Write(sb.ToString());
			}
		}
	}
}
